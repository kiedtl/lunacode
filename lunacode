#!/usr/bin/env bash
#
# lunacode - A lightweight Lunacode compiler
# I had plenty of help from this awesome gist:
# https://gist.github.com/tdeck/58bd5c1f86a27b212811

#############
# Constants #
#############
CELLS=500

###########
# Globals #
###########
# The buffer holds the cells that form the program's working memory
buffer=()
# The stack holds the start pointer for each loop 
stack=()
# The address pointer, into the cell buffer
ap=0

for i in {1..$CELLS}; do
    buffer+=(0)
done

code=$(cat $1)

debug() {
    echo -e "\n\n=============== DEBUG =============="
    echo -e "\ncid\t\tval\t\tchar"
    echo -e "---\t\t---\t\t----\n"
    for ((c = 0; c < ${#buffer[@]}; c++ )); do
        hex=$(printf %x ${buffer[$c]})
        echo -e "[${c}]\t\t${hex}\t\t\x${hex}"
    done
}

###############
# Interpreter #
###############
execute() {
    op=$1
    case "$op" in
        '[') 
            if [[ ${buffer[$ap]} == 0 ]]; then
                depth=1
                while [[ $depth > 0 ]]; do
                    ((ip++))
                    op=${code:$ip:1}
                    if [[ "$op" == '[' ]]; then
                        ((depth++))
                    elif [[ "$op" == ']' ]]; then
                        ((depth--))
                    fi
                done
            else
                stack+=($ip) 
            fi
            ;;
        ']') 
            if [[ ${buffer[$ap]} != 0 ]]; then
                ((ip = stack[${#stack[@]}-1]))
            else
                unset stack[${#stack[@]}-1]
            fi
            ;;

        '{') 
            if [[ ${buffer[$ap]} != 0 ]]; then
                depth=1
                while [[ $depth > 0 ]]; do
                    ((ip++))
                    op=${code:$ip:1}
                    if [[ "$op" == '[' ]]; then
                        ((depth++))
                    elif [[ "$op" == ']' ]]; then
                        ((depth--))
                    fi
                done
            else
                stack+=($ip) 
            fi
            ;;
        '}') 
            if [[ ${buffer[$ap]} == 0 ]]; then
                ((ip = stack[${#stack[@]}-1]))
            else
                unset stack[${#stack[@]}-1]
            fi
            ;;

        '>') ((ap=(ap+1) % CELLS)) ;;
        '<') ((ap=(ap==0) ? CELLS-1 : ap-1)) ;;
        '^') ((ap=0)) ;;

        '+') ((buffer[ap]=(buffer[ap]+1) % 256)) ;;
        '-') ((buffer[ap]=(buffer[ap]==0) ? 255 : buffer[ap]-1)) ;;

        '.') printf "\x$(printf %x ${buffer[$ap]})" ;;
        '&') printf "\x$(printf %x ${buffer[$ap]})" > /dev/stderr ;;
        ',') buffer[$ap]=$(printf "%d" "'$(read -n 1)") ;;
        '*') buffer[$ap]=0 ;;

        '$') echo "" ;;
        '%') exit ;;
        '#') debug ;;
    esac
}

for ((ip = 0; ip < ${#code}; ip++ )); do
    ip2=$((ip+1))
    op=${code:$ip:1}
    op2=${code:$ip2:1}
    execute $op $op2
done